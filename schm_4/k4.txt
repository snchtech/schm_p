–û–∫ ‚Äî –≤–∏–Ω–æ—à—É **`updateConnectionOffset` + `propagateAnchorIndexToChildren`** –≤ –æ–∫—Ä–µ–º–∏–π —Ñ–∞–π–ª —ñ –ø—ñ–¥–∫–ª—é—á–∞—é –Ω–∞–∑–∞–¥ —É `useDiagramState`. –†–æ–±–ª—é —Ü–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ ‚Äú1-–≤-1‚Äù –∑ —Ç–≤–æ—ó–º –∫–æ–¥–æ–º (–±–µ–∑ –∑–º—ñ–Ω–∏ –ª–æ–≥—ñ–∫–∏), –ø—Ä–æ—Å—Ç–æ —á–µ—Ä–µ–∑ factory.

---

## 1) –ù–æ–≤–∏–π —Ñ–∞–π–ª: `features/scheme-editor/model/domain/connectionOffsetUpdate.js`

```js
import { calculateOrthogonalPath, getExitDir, findClosestSegment } from "../../../shared/geometry";
import { clamp, MIN_OFFSET, MAX_OFFSET } from "../state/constants";
import { resolveAttachmentPoint, getBoxForAttachment } from "./attachments";

// üîÅ –æ–Ω–æ–≤–∏—Ç–∏ segIndex/t —É –í–°–Ü–• –¥–æ—á—ñ—Ä–Ω—ñ—Ö –ø—Ä–∏–≤'—è–∑–∫–∞—Ö –Ω–∞ –æ–Ω–æ–≤–ª–µ–Ω–∏–π parent
function propagateAnchorIndexToChildren(next, parentId, updatedAnchors) {
  const fixAtt = (att) => {
    if (att?.type === "line" && att.connectionId === parentId && att.anchorId) {
      const live = (updatedAnchors || []).find((a) => a.id === att.anchorId);
      if (live) {
        return { ...att, segIndex: live.segIndex, t: live.t }; // –∫—Ä–∏—Ç–∏—á–Ω–æ
      }
    }
    return att;
  };

  return next.map((c) => {
    const newFrom = fixAtt(c.from);
    const newTo = fixAtt(c.to);
    if (newFrom !== c.from || newTo !== c.to) {
      return { ...c, from: newFrom, to: newTo };
    }
    return c;
  });
}

export function updateConnectionOffsetFactory({ symbols, setConnections }) {
  return function updateConnectionOffset(connId, newOffset, side = "both", extra = {}) {
    setConnections((prev) => {
      const pad = clamp(newOffset, MIN_OFFSET, MAX_OFFSET);

      let next = [...prev];
      const idx = next.findIndex((c) => c.id === connId);
      if (idx < 0) return prev;

      let conn = next[idx];

      let prevStart = conn.routing?.startOffset ?? 20;
      let prevEnd = conn.routing?.endOffset ?? 20;

      let newStart = prevStart;
      let newEnd = prevEnd;

      if (side === "start") {
        newStart = pad;
        if (typeof extra?.desiredY === "number" || typeof extra?.desiredX === "number") {
          newEnd = pad;
        }
      } else if (side === "end") {
        newEnd = pad;
        if (typeof extra?.desiredY === "number" || typeof extra?.desiredX === "number") {
          newStart = pad;
        }
      } else if (side === "both") {
        newStart = pad;
        newEnd = pad;
      }

      conn = {
        ...conn,
        routing: {
          startOffset: side === "end" ? prevStart : newStart,
          endOffset: side === "start" ? prevEnd : newEnd,
        },
      };

      next[idx] = conn;

      // 2) –∫–æ–≤–∑–∞–Ω–Ω—è —Å–∏–Ω—å–æ–≥–æ —è–∫—ñ—Ä—Ü—è –ø–æ –±–∞—Ç—å–∫—ñ–≤—Å—å–∫—ñ–π –≤–µ—Ä—Ç–∏–∫–∞–ª—ñ/–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—ñ
      if (
        side === "end" &&
        conn.from?.type === "line" &&
        (typeof extra?.desiredY === "number" || typeof extra?.desiredX === "number")
      ) {
        const parentIdx = next.findIndex((c) => c.id === conn.from.connectionId);
        if (parentIdx >= 0) {
          const parent = next[parentIdx];
          const ppts = parent.points || [];
          const si = conn.from.segIndex;

          if (Number.isFinite(si) && 2 * si + 3 < ppts.length) {
            const x1 = ppts[2 * si],
              y1 = ppts[2 * si + 1];
            const x2 = ppts[2 * si + 2],
              y2 = ppts[2 * si + 3];

            // –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç
            if (x1 === x2 && typeof extra.desiredY === "number") {
              const ymin = Math.min(y1, y2),
                ymax = Math.max(y1, y2);
              const y = Math.max(ymin, Math.min(ymax, extra.desiredY));
              const t = y2 === y1 ? 0 : (y - y1) / (y2 - y1);

              const updAnch = (parent.additionalAnchors || []).map((a) =>
                a.id === conn.from.anchorId
                  ? { ...a, x: x1, y, segIndex: si, t, vertexIndex: null }
                  : a,
              );

              next[parentIdx] = { ...parent, additionalAnchors: updAnch };
              conn = { ...conn, from: { ...conn.from, segIndex: si, t } };
              next[idx] = conn;
            }

            // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç
            if (y1 === y2 && typeof extra.desiredX === "number") {
              const xmin = Math.min(x1, x2),
                xmax = Math.max(x1, x2);
              const x = Math.max(xmin, Math.min(xmax, extra.desiredX));
              const t = x2 === x1 ? 0 : (x - x1) / (x2 - x1);

              const updAnch = (parent.additionalAnchors || []).map((a) =>
                a.id === conn.from.anchorId
                  ? { ...a, x, y: y1, segIndex: si, t, vertexIndex: null }
                  : a,
              );

              next[parentIdx] = { ...parent, additionalAnchors: updAnch };
              conn = { ...conn, from: { ...conn.from, segIndex: si, t } };
              next[idx] = conn;
            }
          }
        }
      }

      // 3) –ø–µ—Ä–µ—Ä–∞—Ö—É–Ω–æ–∫ –º–∞—Ä—à—Ä—É—Ç—É –∑ —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –æ—Ñ—Å–µ—Ç—ñ–≤ —Ç–∞ –∫–æ—Ä–æ–±–æ–∫ –æ–±—Ö–æ–¥—É
      const sp = resolveAttachmentPoint(conn.from, symbols, next);
      const ep = resolveAttachmentPoint(conn.to, symbols, next);

      if (sp && ep) {
        const dirFrom = getExitDir(conn.from, ep, next);
        const dirTo = getExitDir(conn.to, sp, next);

        const pts = calculateOrthogonalPath(
          { ...sp, direction: dirFrom },
          { ...ep, direction: dirTo },
          { startOffset: conn.routing.startOffset, endOffset: conn.routing.endOffset },
          getBoxForAttachment(conn.from, symbols),
          getBoxForAttachment(conn.to, symbols),
        );

        const updatedAnchors = (conn.additionalAnchors || []).map((a) => {
          if (a.vertexIndex != null) {
            const vi = a.vertexIndex;
            const vx = pts[2 * vi],
              vy = pts[2 * vi + 1];
            const maxSeg = pts.length / 2 - 2;
            let newSeg = Math.min(Math.max(vi - 1, 0), maxSeg);
            let newT = 0.5;
            return { ...a, x: vx, y: vy, segIndex: newSeg, t: newT, vertexIndex: null };
          }

          let nearest = findClosestSegment(pts, a.x, a.y);
          return { ...a, x: nearest.x, y: nearest.y, segIndex: nearest.segIndex, t: nearest.t };
        });

        next[idx] = {
          ...conn,
          points: pts,
          fromExitDir: dirFrom,
          toExitDir: dirTo,
          additionalAnchors: updatedAnchors,
          routing: conn.routing,
        };

        next = propagateAnchorIndexToChildren(next, connId, updatedAnchors);
      }

      // 4) –ø–µ—Ä–µ—Ä–∞—Ö—É–Ω–æ–∫ –∑–∞–ª–µ–∂–Ω–∏—Ö –∑–≤ º—è–∑–∫—ñ–≤ (—Ç—ñ, —â–æ –ø—Ä–∏—á–µ–ø–ª–µ–Ω—ñ –¥–æ —Ü—ñ—î—ó –ª—ñ–Ω—ñ—ó)
      next = next.map((c) => {
        const dependsOn = (att) => att?.type === "line" && att.connectionId === connId;
        if (!dependsOn(c.from) && !dependsOn(c.to)) return c;

        const sp2 = resolveAttachmentPoint(c.from, symbols, next);
        const ep2 = resolveAttachmentPoint(c.to, symbols, next);
        if (!sp2 || !ep2) return c;

        const df = getExitDir(c.from, ep2, next);
        const dt = getExitDir(c.to, sp2, next);

        const pts2 = calculateOrthogonalPath(
          { ...sp2, direction: df },
          { ...ep2, direction: dt },
          { startOffset: c.routing?.startOffset ?? 20, endOffset: c.routing?.endOffset ?? 20 },
          getBoxForAttachment(c.from, symbols),
          getBoxForAttachment(c.to, symbols),
        );

        return { ...c, points: pts2, fromExitDir: df, toExitDir: dt, routing: c.routing };
      });

      // 5) —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑—É—î–º–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ ¬´—Å–∏–Ω—ñ—Ö¬ª —è–∫–æ—Ä—ñ–≤ –Ω–∞ —ó—Ö–Ω—ñ—Ö –º–∞—Ä—à—Ä—É—Ç–∞—Ö
      next = next.map((c) => {
        if (!c.additionalAnchors?.length) return c;

        const upd = c.additionalAnchors.map((a) => {
          const i = a.segIndex;
          const pts = c.points || [];
          if (i == null || 2 * i + 3 >= pts.length) return a;

          const x1 = pts[2 * i],
            y1 = pts[2 * i + 1];
          const x2 = pts[2 * i + 2],
            y2 = pts[2 * i + 3];

          return { ...a, x: x1 + a.t * (x2 - x1), y: y1 + a.t * (y2 - y1) };
        });

        return { ...c, additionalAnchors: upd, routing: c.routing };
      });

      return next;
    });
  };
}
```

> –ó–≤–µ—Ä–Ω–∏ —É–≤–∞–≥—É: —Ç—É—Ç —ñ–º–ø–æ—Ä—Ç—É—é `MIN_OFFSET/MAX_OFFSET` —ñ–∑ `state/constants`. –ü–µ—Ä–µ–∫–æ–Ω–∞–π—Å—è, —â–æ –≤–æ–Ω–∏ —Ç–∞–º —î (—è —Ä–∞–Ω—ñ—à–µ –ø—Ä–æ–ø–æ–Ω—É–≤–∞–≤ —ó—Ö –≤–∏–Ω–µ—Å—Ç–∏ —Ç—É–¥–∏). –Ø–∫—â–æ —Ç–∏ —ó—Ö –∑–∞–ª–∏—à–∏—à –≤ —ñ–Ω—à–æ–º—É —Ñ–∞–π–ª—ñ ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—ñ–¥–ø—Ä–∞–≤–∏—à —ñ–º–ø–æ—Ä—Ç.

---

## 2) –û–Ω–æ–≤–ª–µ–Ω–Ω—è `features/scheme-editor/model/state/constants.js`

(—â–æ–± `MIN_OFFSET/MAX_OFFSET` –±—É–ª–∏ —Ç–∞–º, —è–∫ —É —Ç–≤–æ—î–º—É —Ñ–∞–π–ª—ñ)

```js
export const MIN_OFFSET = 8;
export const MAX_OFFSET = 300;

export const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
```

---

## 3) –ü—ñ–¥–∫–ª—é—á–∞—î–º–æ –Ω–∞–∑–∞–¥ —É `useDiagramState.js`

–í –∫—ñ–Ω–µ—Ü—å `useDiagramState` –¥–æ–¥–∞—î–º–æ:

```js
import { updateConnectionOffsetFactory } from "./domain/connectionOffsetUpdate";
```

—ñ –Ω–∏–∂—á–µ –≤ —Ç—ñ–ª—ñ:

```js
const updateConnectionOffset = updateConnectionOffsetFactory({
  symbols,
  setConnections,
});
```

—Ç–∞ –¥–æ–¥–∞—î–º–æ –≤ `return { ... }`:

```js
updateConnectionOffset,
```

---

## 4) –ú—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π diff `useDiagramState.js` (—â–æ —Å–∞–º–µ –∑–º—ñ–Ω–∏—Ç–∏)

1. –î–æ–¥–∞—Ç–∏ —ñ–º–ø–æ—Ä—Ç `useEffect`, –±–æ –∑–∞—Ä–∞–∑ –≤—ñ–Ω –≤ –∫–æ–¥—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è:

```js
import { useState, useEffect } from "react";
```

2. –î–æ–¥–∞—Ç–∏ —ñ–º–ø–æ—Ä—Ç `updateConnectionOffsetFactory`
3. –î–æ–¥–∞—Ç–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è `updateConnectionOffset` —á–µ—Ä–µ–∑ factory
4. –î–æ–¥–∞—Ç–∏ `updateConnectionOffset` –≤ return

---

## 5) –ú–∞–ª–µ–Ω—å–∫–µ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è (–∞–ª–µ –º–∏ —Ü–µ –≤–∏—Ä—ñ—à–∏–º–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–º –∫—Ä–æ–∫–æ–º)

`updateConnectionOffsetFactory({ symbols, setConnections })` –±–µ—Ä–µ `symbols` —ñ–∑ –∑–∞–º–∏–∫–∞–Ω–Ω—è ‚Äî —Ç–æ–±—Ç–æ —è–∫—â–æ `symbols` —á–∞—Å—Ç–æ –∑–º—ñ–Ω—é—é—Ç—å—Å—è, —Ñ—É–Ω–∫—Ü—ñ—è –≤—Å–µ –æ–¥–Ω–æ –±—É–¥–µ –∞–∫—Ç—É–∞–ª—å–Ω–∞, –±–æ `useDiagramState` –ø–µ—Ä–µ—Å—Ç–≤–æ—Ä—é—î —ó—ó –Ω–∞ –∫–æ–∂–µ–Ω —Ä–µ–Ω–¥–µ—Ä. –¶–µ –æ–∫, –∞–ª–µ –≤ –º–∞–π–±—É—Ç–Ω—å–æ–º—É, –∫–æ–ª–∏ –ø–µ—Ä–µ–π–¥–µ–º–æ –Ω–∞ reducer/store, —Ü–µ —Å—Ç–∞–Ω–µ —â–µ —á–∏—Å—Ç—ñ—à–µ.

---

–Ø–∫—â–æ —Ö–æ—á–µ—à, –Ω–∞—Å—Ç—É–ø–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º —è:

* –ø—ñ–¥—á–∏—â—É `handleAnchorClick` (—É —Ç–µ–±–µ –∑–∞—Ä–∞–∑ –ø–æ–¥–≤—ñ–π–Ω–∏–π `setConnections`) —Ç–∞–∫, —â–æ–± –±—É–ª–æ **–æ–¥–Ω–µ** –∞—Ç–æ–º–∞—Ä–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è,
* —ñ –≤–∏—Ä—ñ–≤–Ω—è—é selection: –∑–∞—Ä–∞–∑ `selectHightlightEl` –æ—á—ñ–∫—É—î `{type, id}`, –∞ –≤ UI –≤ —Ç–µ–±–µ –º—ñ—Å—Ü—è–º–∏ –ø–µ—Ä–µ–¥–∞—î—Ç—å—Å—è `event`. –¶–µ —Ç–µ–∂ –≤–∞—Ä—Ç–æ –∑–∞—Ñ—ñ–∫—Å–∏—Ç–∏, —â–æ–± –Ω–µ –±—É–ª–æ –±–∞–≥—ñ–≤ —É selection/transformer.
