Так, **реально** — і грід (з перемикачем), і “підказки вирівнювання”/snap як у Visio (центри, краї, середини) **можна зробити в react-konva**. Це не “вбудована кнопка”, але реалізується своїм кодом через Konva API: `Line`, `Layer`, `listening=false`, `dragmove`, `dragend`, `getClientRect()`, `absolutePosition()`.

Нижче — робоча “скелетна” реалізація двох фіч:

---

## 1) Грід для stage/layer (вкл/викл кнопкою)

Ідея: малюємо грід **на окремому Layer**, робимо його `listening={false}`, щоб не заважав клікам/drag.

```jsx
import React, { useMemo } from "react";
import { Layer, Line } from "react-konva";

export function GridLayer({
  width,
  height,
  scale = 1,
  offsetX = 0,
  offsetY = 0,
  visible = true,
  gridSize = 40,
  subDiv = 4, // дрібні лінії (наприклад 10px якщо gridSize=40)
}) {
  const lines = useMemo(() => {
    if (!visible) return [];
    const minor = gridSize / subDiv;

    const res = [];
    const startX = -offsetX / scale;
    const startY = -offsetY / scale;
    const endX = startX + width / scale;
    const endY = startY + height / scale;

    // вертикалі
    for (let x = Math.floor(startX / minor) * minor; x < endX; x += minor) {
      res.push({
        points: [x, startY, x, endY],
        major: Math.abs(x % gridSize) < 0.0001,
      });
    }
    // горизонталі
    for (let y = Math.floor(startY / minor) * minor; y < endY; y += minor) {
      res.push({
        points: [startX, y, endX, y],
        major: Math.abs(y % gridSize) < 0.0001,
      });
    }
    return res;
  }, [width, height, scale, offsetX, offsetY, visible, gridSize, subDiv]);

  if (!visible) return null;

  return (
    <Layer listening={false}>
      {lines.map((l, i) => (
        <Line
          key={i}
          points={l.points}
          stroke={l.major ? "#cfcfcf" : "#e9e9e9"}
          strokeWidth={l.major ? 1 : 0.5}
        />
      ))}
    </Layer>
  );
}
```

Як підключати:

* ти береш `stage.width()/height()`
* береш поточний `layer.scaleX()` та `layer.x()/y()` (якщо ти робиш zoom/pan на layer)
* передаєш у `GridLayer` + прапорець `visible` від кнопки.

> Плюс: грід буде “під камерою” (правильно рухатись при pan/zoom), а не статично поверх.

---

## 2) “Smart guides” + snap під час перетягування (центри/краї як у Visio)

Ідея як у редакторах:

1. Коли тягнеш елемент — рахуємо його **лінії прив’язки** (ліва/центр/права, верх/центр/низ).
2. Рахуємо такі ж лінії для **всіх інших елементів** (і/або меж сцени).
3. Якщо різниця менша за `snapTolerance` — “підтягуємо” позицію елемента і показуємо guide-лінію.

### Компонент шару для guide-ліній

```jsx
import React from "react";
import { Layer, Line } from "react-konva";

export function GuidesLayer({ guides = [] }) {
  return (
    <Layer listening={false}>
      {guides.map((g, idx) => (
        <Line
          key={idx}
          points={g.points}
          stroke="#2f80ed"
          strokeWidth={1}
          dash={[6, 4]}
        />
      ))}
    </Layer>
  );
}
```

### Хелпери snap (ядро логіки)

> Це “мінімальна” версія: вирівнює по X і Y (ліва/центр/права та верх/центр/низ). Працює з будь-якими shape (Rect/Line/Group), головне — щоб вони були draggable.

```js
const SNAP = {
  left: (box) => box.x,
  centerX: (box) => box.x + box.width / 2,
  right: (box) => box.x + box.width,
  top: (box) => box.y,
  centerY: (box) => box.y + box.height / 2,
  bottom: (box) => box.y + box.height,
};

function getNodeBox(node) {
  // Важливо: true -> враховує трансформації/scale/rotation
  return node.getClientRect({ relativeTo: node.getLayer() });
}

function getSnapLinesForNode(node) {
  const box = getNodeBox(node);
  return {
    x: [
      { type: "left", value: SNAP.left(box) },
      { type: "centerX", value: SNAP.centerX(box) },
      { type: "right", value: SNAP.right(box) },
    ],
    y: [
      { type: "top", value: SNAP.top(box) },
      { type: "centerY", value: SNAP.centerY(box) },
      { type: "bottom", value: SNAP.bottom(box) },
    ],
    box,
  };
}

function collectOtherLines(layer, movingNode, selector = ".snap-target") {
  const nodes = layer.find(selector).filter((n) => n !== movingNode);
  const lines = { x: [], y: [] };

  nodes.forEach((n) => {
    const { x, y } = getSnapLinesForNode(n);
    x.forEach((lx) => lines.x.push(lx.value));
    y.forEach((ly) => lines.y.push(ly.value));
  });

  return lines;
}

function findClosestSnap(value, candidates, tolerance) {
  let best = null;
  for (const c of candidates) {
    const diff = Math.abs(c - value);
    if (diff <= tolerance && (!best || diff < best.diff)) {
      best = { target: c, diff };
    }
  }
  return best;
}

/**
 * Повертає:
 * - newAbsPos: {x,y} для node.absolutePosition()
 * - guides: масив ліній для відображення
 */
export function computeSnap({
  movingNode,
  layer,
  tolerance = 6,
  selector = ".snap-target",
}) {
  const moving = getSnapLinesForNode(movingNode);
  const others = collectOtherLines(layer, movingNode, selector);

  const absPos = movingNode.absolutePosition();
  const guides = [];

  let dx = 0;
  let dy = 0;

  // --- snap X ---
  for (const line of moving.x) {
    const snap = findClosestSnap(line.value, others.x, tolerance);
    if (snap) {
      const diff = snap.target - line.value;
      dx = diff; // беремо найближчий (можна покращити: вибрати найменший diff серед усіх)
      guides.push({
        points: [snap.target, -100000, snap.target, 100000], // "нескінченна" вертикаль
      });
      break;
    }
  }

  // --- snap Y ---
  for (const line of moving.y) {
    const snap = findClosestSnap(line.value, others.y, tolerance);
    if (snap) {
      const diff = snap.target - line.value;
      dy = diff;
      guides.push({
        points: [-100000, snap.target, 100000, snap.target], // "нескінченна" горизонталь
      });
      break;
    }
  }

  return {
    newAbsPos: { x: absPos.x + dx, y: absPos.y + dy },
    guides,
  };
}
```

### Використання під час drag (у твоєму елементі)

Ключове: додай shape’ам `name="snap-target"` (або інший селектор), і на `onDragMove` рахуй snap + показуй guides.

```jsx
// приклад для будь-якого елемента (Line/Rect/Group)
<Line
  name="snap-target"
  draggable
  onDragMove={(e) => {
    const node = e.target;
    const layer = node.getLayer();

    const { newAbsPos, guides } = computeSnap({
      movingNode: node,
      layer,
      tolerance: 6,
      selector: ".snap-target",
    });

    // підтягуємо позицію
    node.absolutePosition(newAbsPos);

    // збережи guides у state (наприклад setGuides(guides))
    setGuides(guides);

    layer.batchDraw();
  }}
  onDragEnd={() => setGuides([])}
/>
```

І десь у твоєму Stage:

```jsx
<GuidesLayer guides={guides} />
```

---

## Що ще можна додати “як у Visio”

* Snap не тільки до інших фігур, а й до **меж сторінки/рамки**.
* Snap до **grid** (кроком 10/20/40) — комбінується з guides.
* “Розумні” guides для **однакових відстаней** (distribute spacing) — складніше, але теж реально.
* Оптимізація: під час drag брати список нод **один раз на dragstart**, а не шукати `layer.find()` на кожен `dragmove`.

---

Якщо ти скинеш, **де саме ти робиш zoom/pan (на stage чи на layer)** і як зберігаєш список елементів (масив у state?), я одразу підлаштую код під твою структуру: щоб грід і guides коректно працювали при масштабі, і щоб snapping враховував rotation/scale твоїх фігур.
