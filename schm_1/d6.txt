–¢–∞–∫ ‚Äî **—Ü–µ–π –∫–æ–¥ –º–∞–π–∂–µ —Ç–∞–∫–∏–π —Å–∞–º–∏–π** —ñ –≤ `react-konva` –≤—ñ–Ω **–ø—Ä–∞—Ü—é–≤–∞—Ç–∏–º–µ –±–µ–∑ –∑–º—ñ–Ω**, —è–∫—â–æ —Ç–∏:

1. –ø–µ—Ä–µ–¥–∞—Å–∏ –≤ –Ω—å–æ–≥–æ **—Ä–µ–∞–ª—å–Ω—ñ —ñ–Ω—Å—Ç–∞–Ω—Å–∏ Konva**:

* `stage = stageRef.current.getStage()`
* `layer = layerRef.current` (—Ü–µ –≤–∂–µ Konva.Layer)

2. –≤–∏–∫–ª–∏—á–µ—à –π–æ–≥–æ –≤ `useEffect` —ñ –∑—Ä–æ–±–∏—à `destroy()` —É cleanup.

–Ñ 2 –Ω—é–∞–Ω—Å–∏, —è–∫—ñ —è –± –æ–¥—Ä–∞–∑—É –¥–æ–ø—Ä–∞—Ü—é–≤–∞–≤ –ø—ñ–¥ ‚Äú—Ä–µ–¥–∞–∫—Ç–æ—Ä‚Äù:

### –ù—é–∞–Ω—Å ‚Ññ1: —â–æ–± Space –Ω–µ —Å–∫—Ä–æ–ª–∏–≤ —Å—Ç–æ—Ä—ñ–Ω–∫—É

–¢–∏ –≤–∂–µ –ø–æ—Å—Ç–∞–≤–∏–≤ `{ passive: false }` ‚Äî –æ–∫ üëç
–ê–ª–µ —ñ–Ω–∫–æ–ª–∏ –±—Ä–∞—É–∑–µ—Ä —Å–∫—Ä–æ–ª–∏—Ç—å —Å—Ç–æ—Ä—ñ–Ω–∫—É —â–µ –π –Ω–∞ `wheel`. –Ø–∫—â–æ canvas –≤ —Å–∫—Ä–æ–ª-–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ñ ‚Äî –æ–∫, —è–∫—â–æ –Ω—ñ ‚Äî –º–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∫–æ–≤–æ –±–ª–æ–∫—É–≤–∞—Ç–∏ —Å–∫—Ä–æ–ª —Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ –∫—É—Ä—Å–æ—Ä –Ω–∞–¥ stage (–Ω–µ –æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ).

### –ù—é–∞–Ω—Å ‚Ññ2: draggable –∫–æ–Ω—Ñ–ª—ñ–∫—Ç –ø—ñ–¥ —á–∞—Å –ø–∞–Ω–æ—Ä–∞–º—É–≤–∞–Ω–Ω—è

–¢–≤—ñ–π –∫–æ–¥ –ø–∞–Ω–æ—Ä–∞–º—É–≤–∞–Ω–Ω—è **–Ω–µ –≤–∏–º–∏–∫–∞—î draggable**, —Ç–æ–º—É –µ–ª–µ–º–µ–Ω—Ç–∏ –º–æ–∂—É—Ç—å ‚Äú—á—ñ–ø–ª—è—Ç–∏—Å—å‚Äù. –î–ª—è —Ü—å–æ–≥–æ —ñ –ø–æ—Ç—Ä—ñ–±–µ–Ω lock/unlock.

–ù–∏–∂—á–µ ‚Äî **—Ç–≤—ñ–π –∫–æ–¥**, –∞–ª–µ –∑ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–æ—é –≤—Å—Ç–∞–≤–∫–æ—é draggable-lock (—ñ –∑ –∫–æ—Ä–µ–∫—Ç–Ω–∏–º unlock –≤ destroy).

---

## ‚úÖ –¢–≤—ñ–π `setupLayerZoomPan`, –∞–ª–µ –∑ draggable lock

```js
function createDraggableLock(layer) {
  const prev = new Map();
  let locked = false;

  function lock() {
    if (locked) return;
    locked = true;
    prev.clear();

    layer.find("*").each((node) => {
      if (typeof node.draggable === "function") {
        prev.set(node._id, node.draggable());
        node.draggable(false);
      }
    });
  }

  function unlock() {
    if (!locked) return;
    locked = false;

    layer.find("*").each((node) => {
      if (prev.has(node._id)) node.draggable(prev.get(node._id));
    });

    prev.clear();
  }

  return { lock, unlock };
}

/**
 * Konva editor-like zoom & pan (Layer as viewport).
 */
export function setupLayerZoomPan(stage, layer, {
  zoomStep = 1.15,
  minScale = 0.2,
  maxScale = 6,
  requireCtrlForWheel = false,
  panMode = "mmb_or_space",
} = {}) {
  if (!stage) throw new Error("stage is required");
  if (!layer) throw new Error("layer is required");

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const container = stage.container();
  const dragLock = createDraggableLock(layer);

  // ---------- ZOOM ----------
  const getScale = () => layer.scaleX() || 1;

  function zoomToPoint(nextScale, pointOnStage) {
    const oldScale = getScale();
    const newScale = clamp(nextScale, minScale, maxScale);

    const p = pointOnStage ?? { x: stage.width() / 2, y: stage.height() / 2 };
    const layerPos = layer.position();

    const worldPoint = {
      x: (p.x - layerPos.x) / oldScale,
      y: (p.y - layerPos.y) / oldScale,
    };

    layer.scale({ x: newScale, y: newScale });

    layer.position({
      x: p.x - worldPoint.x * newScale,
      y: p.y - worldPoint.y * newScale,
    });

    layer.batchDraw();
  }

  function onWheel(e) {
    e.evt.preventDefault();
    if (requireCtrlForWheel && !e.evt.ctrlKey) return;

    const pointer = stage.getPointerPosition();
    if (!pointer) return;

    const direction = e.evt.deltaY > 0 ? -1 : 1;
    const factor = direction > 0 ? zoomStep : 1 / zoomStep;

    zoomToPoint(getScale() * factor, pointer);
  }

  stage.on("wheel", onWheel);

  // ---------- PAN ----------
  let isPanning = false;
  let lastClient = null;
  let spaceDown = false;

  const keyDown = (ev) => {
    if (ev.code === "Space") {
      spaceDown = true;
      ev.preventDefault?.();
      if (!isPanning) container.style.cursor = "grab";
    }
  };

  const keyUp = (ev) => {
    if (ev.code === "Space") {
      spaceDown = false;
      if (!isPanning) container.style.cursor = "default";
    }
  };

  window.addEventListener("keydown", keyDown, { passive: false });
  window.addEventListener("keyup", keyUp);

  function canStartPan(evt) {
    const isMMB = evt.button === 1;
    const isLMB = evt.button === 0;

    if (panMode === "mmb") return isMMB;
    if (panMode === "space") return isLMB && spaceDown;
    return isMMB || (isLMB && spaceDown);
  }

  function onMouseDown(e) {
    const evt = e.evt;
    if (!canStartPan(evt)) return;

    isPanning = true;
    lastClient = { x: evt.clientX, y: evt.clientY };

    dragLock.lock();                 // üîí –≤–∏–º–∏–∫–∞—î–º–æ draggable
    container.style.cursor = "grabbing";
    evt.preventDefault();
  }

  function onMouseMove(e) {
    if (!isPanning || !lastClient) return;

    const evt = e.evt;
    const dx = evt.clientX - lastClient.x;
    const dy = evt.clientY - lastClient.y;

    layer.position({ x: layer.x() + dx, y: layer.y() + dy });

    lastClient = { x: evt.clientX, y: evt.clientY };
    layer.batchDraw();
  }

  function stopPan() {
    if (!isPanning) return;
    isPanning = false;
    lastClient = null;

    dragLock.unlock();               // üîì –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ draggable
    container.style.cursor = spaceDown ? "grab" : "default";
  }

  stage.on("mousedown", onMouseDown);
  stage.on("mousemove", onMouseMove);
  stage.on("mouseup", stopPan);
  stage.on("mouseleave", stopPan);

  // ---------- API ----------
  function zoomIn() { zoomToPoint(getScale() * zoomStep); }
  function zoomOut() { zoomToPoint(getScale() / zoomStep); }

  function reset() {
    layer.scale({ x: 1, y: 1 });
    layer.position({ x: 0, y: 0 });
    layer.batchDraw();
  }

  function destroy() {
    stage.off("wheel", onWheel);
    stage.off("mousedown", onMouseDown);
    stage.off("mousemove", onMouseMove);
    stage.off("mouseup", stopPan);
    stage.off("mouseleave", stopPan);

    window.removeEventListener("keydown", keyDown);
    window.removeEventListener("keyup", keyUp);

    // –Ω–∞ –≤—Å—è–∫ –≤–∏–ø–∞–¥–æ–∫
    dragLock.unlock();
    container.style.cursor = "default";
  }

  return { zoomIn, zoomOut, reset, getScale, setScale: (s) => zoomToPoint(s), destroy };
}
```

---

## –Ø–∫ —Ü–µ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ –≤ react-konva

```jsx
const stage = stageRef.current.getStage();
const layer = layerRef.current;

useEffect(() => {
  if (!stage || !layer) return;

  const api = setupLayerZoomPan(stage, layer, { panMode: "mmb_or_space" });
  return () => api.destroy();
}, []);
```

---

### –í–∏—Å–Ω–æ–≤–æ–∫

* **–¢–∞–∫**, —Ç–≤—ñ–π –∫–æ–¥ **–±—É–¥–µ —Ç–∞–∫–∏–º —Å–∞–º–∏–º** —É react-konva.
* –†—ñ–∑–Ω–∏—Ü—è –ª–∏—à–µ –≤ **refs + useEffect cleanup**.
* –î–ª—è ‚Äú—Ä–µ–¥–∞–∫—Ç–æ—Ä–Ω–æ–≥–æ‚Äù UX —è –± **–æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–æ** –¥–æ–¥–∞–≤ draggable-lock (—è–∫ –≤–∏—â–µ).

–Ø–∫—â–æ —Å–∫–∞–∂–µ—à: —Ç–∏ —Ö–æ—á–µ—à –ø–∞–Ω–æ—Ä–∞–º—É–≤–∞—Ç–∏ **—Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ Space –∑–∞—Ç–∏—Å–Ω—É—Ç–æ** (–±–µ–∑ MMB) —á–∏ –∑–∞–ª–∏—à–∞—î–º–æ –æ–±–∏–¥–≤–∞ ‚Äî –ø—ñ–¥–∂–µ–Ω—É –ø—ñ–¥ —Ç–≤–æ—é UX-–ª–æ–≥—ñ–∫—É.
